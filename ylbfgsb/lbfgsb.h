/*
 * lbfgsb.h -
 *
 * Definitions for C wrapper of L-BFGS-B FORTRAN routines.
 *
 *-----------------------------------------------------------------------------
 *
 * This software is licensed under the MIT "Expat" License.
 *
 * Copyright (C) 2002-2005, 2015: Éric Thiébaut <eric.thiebaut@univ-lyon1.fr>
 *
 *-----------------------------------------------------------------------------
 */

#ifndef _LBFGSB_H
#define _LBFGSB_H 1

/* The following macros may be redefined to establish FORTRAN-C data types
   equivalences. */
#define lbfgsb_integer_t int              /* FORTRAN "INTEGER" type */
#define lbfgsb_logical_t int              /* FORTRAN "LOGICAL" type */
#define lbfgsb_strlen_t  lbfgsb_integer_t /* length of strings */
#define lbfgsb_real_t    double           /* FORTRAN "DOUBLE PRECISION" type */

/* Length of TASK and CSAVE arrays in LBFGSB. */
#define LBFGSB_TASK_LENGTH 60

/* C++ needs to know that types and declarations are C, not C++. */
#ifdef  __cplusplus
# define _LBFGSB_BEGIN_DECLS  extern "C" {
# define _LBFGSB_END_DECLS    }
#else
# define _LBFGSB_BEGIN_DECLS  /* empty */
# define _LBFGSB_END_DECLS    /* empty */
#endif
_LBFGSB_BEGIN_DECLS

/* Values returned by lbfgsb. */
#define LBFGSB_START       0
#define LBFGSB_FG          1
#define LBFGSB_NEW_X       2
#define LBFGSB_CONVERGENCE 3
#define LBFGSB_WARNING     4
#define LBFGSB_ERROR       5

extern int lbfgsb(lbfgsb_integer_t n,
                  lbfgsb_integer_t m,
                  lbfgsb_real_t x[],
                  lbfgsb_real_t *f,
                  lbfgsb_real_t g[],
                  const lbfgsb_real_t l[],
                  const lbfgsb_real_t u[],
                  const lbfgsb_integer_t bnd[],
                  lbfgsb_real_t factr,
                  lbfgsb_real_t pgtol,
                  char task[],
                  char csave[],
                  lbfgsb_integer_t isave[],
                  lbfgsb_real_t dsave[],
                  lbfgsb_integer_t iprint);
/*
 *   This subroutine uses the limited memory BFGS method to solve a bound
 *   constrained optimization problem.
 *
 *   N is an integer variable.
 *      On entry N is the dimension of the problem.
 *      On exit N is unchanged.
 *
 *   M is an integer variable.
 *      On entry M is the maximum number of variable metric corrections
 *        used to define the limited memory matrix.
 *      On exit M is unchanged.
 *
 *   X is a double precision array of dimension N.
 *      On entry X is an approximation to the solution.
 *      On exit X is the current approximation.
 *
 *   F is a double precision variable.
 *      on first entry F is unspecified.
 *      On final exit F is the value of the function at X.
 *
 *   G is a double precision array of dimension N.
 *      On first entry G is unspecified.
 *      On final exit G is the value of the gradient at X.
 *
 *   L is a double precision array of dimension N.
 *      On entry L is the lower bound on X.
 *      On exit L is unchanged.
 *
 *   U is a double precision array of dimension N.
 *      On entry U is the upper bound on X.
 *      On exit U is unchanged.
 *
 *   BND is an integer array of dimension N.
 *      On entry BND represents the type of bounds imposed on the
 *        variables, and must be specified as follows:
 *        BND(i)=0 if X(i) is unbounded,
 *               1 if X(i) has only a lower bound,
 *               2 if X(i) has both lower and upper bounds, and
 *               3 if X(i) has only an upper bound.
 *      On exit BND is unchanged.
 *
 *   FACTR is a double precision variable.
 *      On entry FACTR >= 0 is specified by the user.  The iteration
 *        will stop when
 *
 *        (F^k - F^{k+1})/max{|F^k|,|F^{k+1}|,1} <= FACTR*EPSMCH
 *
 *        where EPSMCH is the machine precision, which is automatically
 *        generated by the code. Typical values for FACTR: 1.d+12 for
 *        low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
 *        high accuracy.
 *      On exit FACTR is unchanged.
 *
 *   PGTOL is a double precision variable.
 *      On entry PGTOL >= 0 is specified by the user.  The iteration
 *        will stop when
 *
 *                max{|PG(i)|; i = 1, ..., n} <= PGTOL
 *
 *        where PG(i) is the i-th component of the projected gradient.
 *      On exit PGTOL is unchanged.
 *
 *   TASK is a working array of characters of length 60 indicating
 *      the current job when entering and quitting this subroutine.
 *      TASK must be initialized to "START" upon first call, then TASK
 *      must not be modified between calls.
 *
 *   CSAVE is a working array of characters of length 60.  CSAVE must not
 *      be modified between calls.
 *
 *   ISAVE is an integer working array of length 3*N + 27.
 *      ISAVE must not be modified between calls.  On exit with
 *      TASK = "NEW_X", the following information is available:
 *        ISAVE[0] = the total number of intervals explored in the
 *                   search of Cauchy points;
 *        ISAVE[4] = the total number of skipped BFGS updates before
 *                   the current iteration;
 *        ISAVE[8] = the number of current iteration;
 *        ISAVE[9] = the total number of BFGS updates prior the current
 *                   iteration;
 *        ISAVE[11] = the number of intervals explored in the search of
 *                    Cauchy point in the current iteration;
 *        ISAVE[12] = the total number of function and gradient
 *                    evaluations;
 *        ISAVE[14] = the number of function value or gradient
 *                    evaluations in the current iteration;
 *        if ISAVE[15] = 0, then the subspace argmin is within the box;
 *        if ISAVE[15] = 1, then the subspace argmin is beyond the box;
 *        ISAVE[16] = number of free variables in the current iteration;
 *        ISAVE[17] = number of active constraints in the current iteration;
 *        N + 1 - ISAVE[18] = number of variables leaving the set of active
 *                            constraints in the current iteration;
 *        ISAVE[19] = number of variables entering the set of active
 *                    constraints in the current iteration.
 *        if ISAVE[23] = TRUE, then the initial X has been replaced by
 *                             its projection in the feasible set;
 *        if ISAVE[24] = TRUE, then the problem is constrained;
 *        if ISAVE[25] = TRUE, then each variable has upper and lower bounds;
 *
 *   DSAVE is a double precision working array of length
 *           (2*M + 4)*N + (11*M + 8)*M + 29
 *      DSAVE must not be modified between calls.  On exit with
 *      TASK = "NEW_X", the following information is available:
 *	  DSAVE[0] = current 'THETA' in the BFGS matrix;
 *	  DSAVE[1] = F(X) in the previous iteration;
 *	  DSAVE[2] = FACTR*EPSMCH;
 *	  DSAVE[3] = 2-norm of the line search direction vector;
 *	  DSAVE[4] = the machine precision epsmch generated by the code;
 *	  DSAVE[6] = the accumulated time spent on searching for Cauchy points;
 *	  DSAVE[7] = the accumulated time spent on subspace minimization;
 *	  DSAVE[8] = the accumulated time spent on line search;
 *	  DSAVE[10] = the slope of the line search function at the current
 *        	      point of line search;
 *	  DSAVE[11] = the maximum relative step length imposed in line search;
 *	  DSAVE[12] = the infinity norm of the projected gradient;
 *	  DSAVE[13] = the relative step length in the line search;
 *	  DSAVE[14] = the slope of the line search function at the starting
 *        	      point of the line search;
 *	  DSAVE[15] = the square of the 2-norm of the line search direction
 *	  	      vector.
 *
 *   IPRINT is an integer variable that must be set by the user.
 *      It controls the frequency and type of output generated:
 *       IPRINT<0    no output is generated;
 *       IPRINT=0    print only one line at the last iteration;
 *       0<IPRINT<99 print also F and |proj G| every IPRINT iterations;
 *       IPRINT=99   print details of every iteration except N-vectors;
 *       IPRINT=100  print also the changes of active set and final X;
 *       IPRINT>100  print details of every iteration including X and G;
 *      When IPRINT > 0, the file iterate.dat will be created to
 *                       summarize the iteration.
 *
 *   The returned value can be used as a shortcut to the value of TASK:
 *       return value = 0    if TASK = "START"
 *                      1              "FG"
 *                      2              "NEW_X"
 *                      3              "CONVERGENCE"
 *                      4              "WARNING"
 *                      5              "ERROR"
 *
 *
 *   References:
 *
 *      [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited
 *      memory algorithm for bound constrained optimization'',
 *      SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.
 *
 *      [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a
 *      limited memory FORTRAN code for solving bound constrained
 *      optimization problems'', Tech. Report, NAM-11, EECS Department,
 *      Northwestern University, 1994.
 *
 *      (Postscript files of these papers are available via anonymous
 *       ftp to ece.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)
 *
 *                          *  *  *
 *
 *   NEOS, November 1994. (Latest revision April 1997.)
 *   Optimization Technology Center.
 *   Argonne National Laboratory and Northwestern University.
 *   Written by
 *                       Ciyou Zhu
 *   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.
 *
 *                          *  *  *
 */

_LBFGSB_END_DECLS
#endif /* _LBFGSB_H */

/*
 * Local Variables:
 * mode: C
 * c-basic-offset: 2
 * tab-width: 8
 * indent-tabs-mode: nil
 * fill-column: 79
 * coding: utf-8
 * ispell-local-dictionary: "american"
 * End:
 */
